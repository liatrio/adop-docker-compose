#!/bin/bash

SUB_CMD_NAME="test"

cmd_desc() {
    echo "For confirming LDOP functionality during development."
}

cmd_usage() {
    echo "usage: ${CMD_NAME} ${SUB_CMD_NAME} <subcommand>"
}

help() {
    echo
    cmd_usage echo
    echo
    echo "Available subcommands are:"
    printf "    %-20s   %s\n" "basic" "Test basic functionality."
    printf "    %-20s   %s\n" "help" "Prints this help information"
    echo
}

basic() {
  echo
  echo "#######################"
  echo "# Testing in Progress #"
  echo "#######################"
  echo
 
  echo "/adop compose down --volumes"
  ${CONF_DIR}/adop compose down --volumes
  
  echo "/adop compose init --without-pull"
  ${CONF_DIR}/adop compose init --without-load

  # Sources to obtain the password for Jenkins
  source ${CONF_DIR}/conf/env.provider.sh
  source ${CONF_DIR}/credentials.generate.sh
  source ${CONF_DIR}/env.config.sh 

  ############### Test if Load_Platform job works properly ###############
  echo "Testing if Load_Platform job is successful..."

  # The URL of the job Load_Platform as hit from within the Jenkins container
  JOB_URL=localhost:8080/jenkins/job/Load_Platform

  # A value to determine if the job is currently executing
  GREP_RETURN_CODE=0

  # Trigger the parameterized job with default parameters.
  # -s silent, don't output curl details
  # docker exec jenkins, execute from within jenkins container
  # --data '', execute the curl as a POST
  # /buildWithParameters, build with default parameters
  docker exec jenkins curl -s --data '' jenkins:${PASSWORD_JENKINS}@${JOB_URL}/buildWithParameters
  echo "...triggered the job Load_Platform to build with default parameters..."

  # Disable -e as set in ADOP...
  set +e

  # ...while the successful curl of the lastBuild information
  # holds a null value as the result...
  # "while the job is still executing"
  while [ $GREP_RETURN_CODE -eq 0 ]
  do
    # Give the job time to build, check every 30 seconds
    echo "...waiting 30 seconds for Load_Platform job to execute..."
    sleep 30
    CURL=$(docker exec jenkins curl -s jenkins:${PASSWORD_JENKINS}@${JOB_URL}/lastBuild/api/json)
    # If the curl command did not error...
    # (only update the "job currently executing" variable if the curl succeeds)
    if [ $? -eq 0 ]
    then
      # Grep will return 0 (successfully obtained null result) 
      # while the build is running
      echo $CURL | grep building\":true > /dev/null
      GREP_RETURN_CODE=$?
    fi
    # If the curl command errored, sleep and try again
  done
  RESULT=$(echo $CURL | grep -E -o "result\":.{0,10}" | awk -F'"' '{print $3}')
  echo "...Load_Platform job completed! Build Status: $RESULT"

  set -e
  
  ############### Tested if Load_Platform job works properly ###############

  echo
  echo "#######################"
  echo "#  Testing Complete   #"
  echo "#######################"
  echo

  echo
  echo "#######################"
  echo "#  Testing Results:   #"
  echo "#######################"
  echo

  echo
  echo "Load_Platform Build Result: $RESULT"
  echo
  echo "Docker Containers with Non-running Statuses:"
  docker ps -f "status=created" --format "{{.Names}}: {{.Status}}"
  docker ps -f "status=restarting" --format "{{.Names}}: {{.Status}}"
  docker ps -f "status=removing" --format "{{.Names}}: {{.Status}}"
  docker ps -f "status=paused" --format "{{.Names}}: {{.Status}}"
  docker ps -f "status=exited" --format "{{.Names}}: {{.Status}}"
  docker ps -f "status=dead" --format "{{.Names}}: {{.Status}}"
  echo
}

shift $(($OPTIND -1))
SUBCOMMAND_OPT="${1:-help}"

# Only shift if there are other parameters
if [ $# -ge 1 ]; then
    shift
fi

if [ ! -z ${SUBCOMMAND_OPT} ]; then
  case ${SUBCOMMAND_OPT} in
    "cmd_desc"|"help")
        ${SUBCOMMAND_OPT}
        ;;
    "basic")
        basic
        ;;
    *)
        echo "Invalid subcommand."
        help
        exit 1
        ;;
  esac
fi
